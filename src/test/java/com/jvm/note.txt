
java堆线程共享的，java栈线程私有的

内存溢出和内存泄漏：
	内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用
	内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，最终会导致out of memory
	
虚拟机栈溢出：
	如果线程请求的栈深度大于虚拟机所允许的最大深度，抛StackOverflowError异常
	如果虚拟器扩展时无法申请足够的内存空间，抛OutOfMemoryError异常
	
新生代GC：Minor GC，	老年代GC：Major GC/Full GC

jdk可视化虚拟机性能监控工具：
	E:\Program\Java\jdk1.7.0_80\bin\jconsole.exe
	

类加载器：
	1.启动类加载器（Bootstrap ClassLoader）：加载<JAVA_HOME>\lib 类库到虚拟机内存
	2.扩展类加载器（Extension ClassLoader）：加载<JAVA_HOME>\lib\ext 类库到虚拟机内存
	3.应用程序类加载器（Application ClassLoader）：ClassLoader.getSystemClassLoader()，加载用户类路径上指定的类库

动态类型语言：运行期进行类型检查的语言，包括js，php，Python等
静态类型语言：编译器进行类型检查的语言，包括c++，java（所以静态语言修改后需要重启服务，但运行更快）

基于栈的字节码解释执行引擎
java虚拟机解释执行和编译执行：
	Java程序最初是仅仅通过解释器解释执行的，即对字节码逐条解释执行（基于栈的指令集），这种方式的执行速度相对会比较慢，
	尤其当某个方法或代码块运行的特别频繁时，这种方式的执行效率就显得很低。
	于是后来在虚拟机中引入了JIT编译器（即时编译器），当虚拟机发现某个方法或代码块运行特别频繁时，就会把这些代码认定为“Hot Spot Code”（热点代码），
	为了提高热点代码的执行效率，在运行时，虚拟机将会把这些字节码编译成与本地平台相关的机器码，并进行各层次的优化，完成这项任务的正是JIT编译器。
	二者各有优势：当程序需要迅速启动和执行时，解释器可以首先发挥作用，省去编译的时间，立即执行；
	当程序运行后，随着时间的推移，编译器逐渐会发挥作用，把越来越多的字节码转变成机器码后，
	可以获取更高的执行效率。解释执行可以节约内存，而编译执行可以提升效率。